# Сервис Service-Int

<p>Основная функция зарегистрировать клиента</p>

## Api

`POST http://localhost:20028/register`

| Поле | Описание |
|------|----------|
| name | Имя      |
|birthday| Дата рождения|

Пример Json:
```json
{
    "name": "aasdzxcf",
    "birthDay":"16.09.1994"
}
```
[Диаграмма последовательностей](E:\workspace\service-int\service-int-service\diagrams\Registration.puml) 

## Spring Integration notes
Основные компоненты Spring Integration таковы.
- Сообщение (message). Универсальная обертка для любого Java-объекта.
Состоит из заголовков и содержимого. Заголовки обычно содержат важную
информацию, например идентификатор, метку даты/времени, идентификатор корреляции и обратный адрес, и конечно, вы можете добавлять свои
собственные поля. Содержимое может представлять собой данные произвольного типа, от байтовых массивов до пользовательских объектов. Описание заголовков и содержимого можно найти в модуле spring-messaging
в пакете org.springframework.messaging.
```java
public interface Message<T> {
T getPayload();
MessageHeaders getHeaders();
}
```
Как видите, ничего необычного в этом определении нет.
- **Канал передачи сообщений (message channel).** Архитектура, состоящая из
программных каналов и фильтров, очень похожа на команды операционной системы Unix. Для ее использования необходимы генераторы и потребители: генератор отправляет сообщение в канал передачи сообщений,
а потребитель его получает 

![alt text](E:\workspace\service-int\service-int-service\diagrams\MessageChannel.png)


- **Конечная точка сообщений (Message endpoint).** Фильтр, соединяющий код
приложения с фреймворком обмена сообщениями. Большинство этих конечных точек входят в число реализаций из Enterprise Integration Patterns.
- **Фильтр (Filter).** Фильтр сообщений определяет, когда сообщение следует
передавать в выходной канал.
- **Модификатор (Transformer).** Модификатор сообщений модифицирует
содержимое или структуру сообщения и передает его в выходной канал.
- **Маршрутизатор (Router).** Маршрутизатор сообщений определяет на основе заданных правил, что делать и куда отправлять сообщение. Эти правила
могут содержаться в заголовках или в содержимом сообщения. Существует
множество возможных паттернов для маршрутизаторов сообщений. Я покажу вам по крайней мере один из них.
- **Разделитель (Splitter).** Разделитель сообщений получает сообщение
(по входному каналу), разбивает его и возвращает несколько новых сообщений (по выходному каналу).
- **Активатор сервиса (Service activator).** Конечная точка, играющая роль
сервиса: получающая (по входному каналу) и обрабатывающая сообщение. Может завершать поток интеграции, возвращать то же сообщение или
возвращать совершенно новое (по выходному каналу).
- **Агрегатор (Aggregator).** Эта конечная точка сообщений получает несколько
сообщений (по входному каналу), объединяет их в одно новое сообщение
(на основе стратегии выпуска) и выдает его наружу (по выходному каналу).
- **Адаптеры каналов (Channel adapters).** Конечная точка, соединяющая
канал передачи сообщений с другими системами или транспортными протоколами. Spring Integration предоставляет как входные, так и выходные
адаптеры. На случай, когда требуется ответ, в нем есть адаптер-шлюз.
Они используются чаще всего. Почему? Если вашему приложению нужно
подключиться к RabbitMQ, JMS, FTP, файловой системе, HTTP или любой
другой технологии, программировать клиент не нужно, в Spring Integration
всегда найдется адаптер для подключения к ней.

## Конфигурация
В случае Spring Integration есть несколько способов настройки всех компонентов (сообщений, каналов передачи сообщений и конечных точек сообщений):
XML, классы JavaConfig, аннотации и новый DSL интеграции. В данном проекте использовался именно DSL подход.

Пример: 

```java
@Configuration
@Slf4j
@EnableIntegration
public class CdiRegistrationFlowConfiguration {

    @Bean("cdiChannel")
    public MessageChannel cdiChannel() {
        return new DirectChannel();
    }


    @Bean
    public IntegrationFlow amqpFromCdiChannelFlow() {
        return IntegrationFlows.from(cdiChannel())
                .log(message -> "Handle message from cdiChannel : Received Message : " + message.getPayload())
                .handle(m -> log.info("Just do some logging: {}", m))
                .get();
    }
}
```

- **Интерфейс IntegrationFlow.** Обеспечивает видимость DSL как компонента (необходима аннотация @Bean). Этот интерфейс имеет стандартную
реализацию фабрики IntegrationFlowBuilder, которая определяет поток интеграции. Он регистрирует все компоненты, такие как каналы передачи
сообщений, конечные точки и т. д.
- **Класс IntegrationFlows.** Этот класс предоставляет текучий API для построения потока интеграции. В него можно легко включать конечные точки
для модификации, фильтрации, обработки, разбиения, маршрутизации
и сопряжения. В качестве аргументов для этих конечных точек можно
использовать любые лямбда-выражения Java 8 (и более поздних версий).
- **from.** Перегруженный метод, в который обычно передается источник сообщения; в данном случае мы вызываем метод input, возвращающий экземпляр DirectChannel через текучий API MessageChannels.
- **filter.** Этот перегруженный метод заполняет MessageFilter. MessageFilter
передает выполнение MessageSelector, который, если селектор принимает
сообщение, отправляет его в выходной канал фильтра.
- **transform.** Метод может принимать на входе лямбда-выражение, но фактически получает экземпляр GenericTransformer<S,T>, где S представляет собой
источник, а T — тип, к которому производится модификация. Здесь можно
использовать готовые модификаторы, например ObjectToJsonTransformer,
FileToStringTransformer и т. д. В нашем примере роль источника играет тип
класса (ToDo) и выполняется лямбда-выражение, в данном случае получение
описания запланированного дела и модификация его к верхнему регистру.
- **handle.** Перегруженный метод для заполнения ServiceActivatingHandler.
Обычно можно использовать POJO, что позволяет получить сообщение
и либо вернуть новое сообщение, либо инициировать дополнительный
вызов. 
- **@EnableIntegration.** Аннотация настраивает все необходимые для нашего потока компоненты Spring Integration. Она регистрирует
различные встроенные компоненты, например errorChannel, LoggingHandler,
taskScheduler и др., дополняющие наш поток интеграции. Эта аннотация
необходима при использовании Java-конфигураций, аннотаций и DSL
в приложениях Spring Boot.

### Message Channels


```java
public interface MessageChannel {

    boolean send(Message message);

    boolean send(Message message, long timeout);
}
```

- **PollableChannel** Поскольку каналы сообщений могут буферизировать или не буферизовать сообщения, два подинтерфейса определяют поведение буферизующего (опрашиваемого) и небуферизующего (подписываемого) канала.

```java
public interface PollableChannel extends MessageChannel {

    Message<?> receive();

    Message<?> receive(long timeout);

}
```

- **SubscribableChannel** Базовый интерфейс SubscribableChannel отправляет сообщения непосредственно своим подписанным экземплярам MessageHandler. Поэтому они не предоставляют методы приема для поллинга.
Вместо этого они определяют методы управления этими подписчиками.
```java
public interface SubscribableChannel extends MessageChannel {

    boolean subscribe(MessageHandler handler);

    boolean unsubscribe(MessageHandler handler);

}
```

Задачи:
1. Можно ли через SI обобщить все 5 каналов? (Kafka, RabbitMq, Rest, Graphql**, Tibco)
2. Проверить возможность решения задач через Spring Cloud Stream